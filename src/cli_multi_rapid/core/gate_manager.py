#!/usr/bin/env python3
"""
Gate Manager - Verification gates and quality checks

Handles execution and validation of verification gates to ensure
workflow quality and compliance.
"""

from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional

import json


class GateType(Enum):
    """Supported gate types."""

    TESTS_PASS = "tests_pass"
    DIFF_LIMITS = "diff_limits"
    SCHEMA_VALID = "schema_valid"
    CUSTOM = "custom"


@dataclass
class GateResult:
    """Result of executing a verification gate."""

    gate_id: str
    gate_type: GateType
    success: bool
    message: str
    details: Optional[Dict[str, Any]] = None


class GateManager:
    """
    Manage verification gates and quality checks.

    Responsibilities:
    - Execute gate checks
    - Validate artifacts
    - Aggregate gate results
    - Support extensibility for custom gates
    """

    def __init__(self):
        """Initialize gate manager."""
        self._gate_handlers: Dict[GateType, Callable] = {
            GateType.TESTS_PASS: self._check_tests_pass,
            GateType.DIFF_LIMITS: self._check_diff_limits,
            GateType.SCHEMA_VALID: self._check_schema_valid,
        }
        self._custom_handlers: Dict[str, Callable] = {}

    def execute_gates(
        self,
        gates: List[Dict[str, Any]],
        artifacts: List[str],
        context: Optional[Dict[str, Any]] = None
    ) -> List[GateResult]:
        """
        Execute all verification gates.

        Args:
            gates: List of gate definitions
            artifacts: Artifact paths generated by workflow
            context: Additional context for gate execution

        Returns:
            List of GateResult objects
        """
        results = []

        for gate in gates:
            result = self.execute_gate(gate, artifacts, context)
            results.append(result)

        return results

    def execute_gate(
        self,
        gate: Dict[str, Any],
        artifacts: List[str],
        context: Optional[Dict[str, Any]] = None
    ) -> GateResult:
        """
        Execute a single verification gate.

        Args:
            gate: Gate definition
            artifacts: Artifact paths
            context: Additional context

        Returns:
            GateResult
        """
        gate_id = gate.get("id", "unknown")
        gate_type_str = gate.get("type", "custom")

        try:
            gate_type = GateType(gate_type_str)
        except ValueError:
            gate_type = GateType.CUSTOM

        # Get handler
        if gate_type == GateType.CUSTOM:
            # Check custom handlers
            custom_type = gate.get("custom_type", gate_type_str)
            handler = self._custom_handlers.get(custom_type)
            if not handler:
                return GateResult(
                    gate_id=gate_id,
                    gate_type=gate_type,
                    success=False,
                    message=f"No handler for custom gate type: {custom_type}"
                )
        else:
            handler = self._gate_handlers.get(gate_type)
            if not handler:
                return GateResult(
                    gate_id=gate_id,
                    gate_type=gate_type,
                    success=False,
                    message=f"No handler for gate type: {gate_type_str}"
                )

        # Execute gate
        try:
            return handler(gate, artifacts, context)
        except Exception as e:
            return GateResult(
                gate_id=gate_id,
                gate_type=gate_type,
                success=False,
                message=f"Gate execution failed: {str(e)}"
            )

    def _check_tests_pass(
        self,
        gate: Dict[str, Any],
        artifacts: List[str],
        context: Optional[Dict[str, Any]]
    ) -> GateResult:
        """Check if tests pass from test report artifact."""
        gate_id = gate.get("id", "tests_pass")

        # Find test report artifact
        test_report_path = gate.get("artifact", "artifacts/test_report.json")

        if not Path(test_report_path).exists():
            return GateResult(
                gate_id=gate_id,
                gate_type=GateType.TESTS_PASS,
                success=False,
                message=f"Test report not found: {test_report_path}"
            )

        # Load and check test report
        try:
            with open(test_report_path, encoding="utf-8") as f:
                report = json.load(f)
        except Exception as e:
            return GateResult(
                gate_id=gate_id,
                gate_type=GateType.TESTS_PASS,
                success=False,
                message=f"Failed to load test report: {str(e)}"
            )

        tests_passed = report.get("passed", 0)
        tests_failed = report.get("failed", 0)

        success = tests_failed == 0 and tests_passed > 0

        return GateResult(
            gate_id=gate_id,
            gate_type=GateType.TESTS_PASS,
            success=success,
            message=f"Tests: {tests_passed} passed, {tests_failed} failed",
            details={"passed": tests_passed, "failed": tests_failed}
        )

    def _check_diff_limits(
        self,
        gate: Dict[str, Any],
        artifacts: List[str],
        context: Optional[Dict[str, Any]]
    ) -> GateResult:
        """Check if diff size is within limits."""
        gate_id = gate.get("id", "diff_limits")
        max_files = gate.get("max_files", 100)
        max_lines = gate.get("max_lines", 1000)

        # Get diff stats from context or artifact
        diff_stats = (context or {}).get("diff_stats", {})

        files_changed = diff_stats.get("files_changed", 0)
        lines_changed = diff_stats.get("lines_changed", 0)

        within_limits = files_changed <= max_files and lines_changed <= max_lines

        return GateResult(
            gate_id=gate_id,
            gate_type=GateType.DIFF_LIMITS,
            success=within_limits,
            message=f"Diff: {files_changed}/{max_files} files, {lines_changed}/{max_lines} lines",
            details={
                "files_changed": files_changed,
                "lines_changed": lines_changed,
                "within_limits": within_limits
            }
        )

    def _check_schema_valid(
        self,
        gate: Dict[str, Any],
        artifacts: List[str],
        context: Optional[Dict[str, Any]]
    ) -> GateResult:
        """Check if artifact is valid against schema."""
        gate_id = gate.get("id", "schema_valid")
        artifact_path = gate.get("artifact")
        schema_path = gate.get("schema")

        if not artifact_path or not schema_path:
            return GateResult(
                gate_id=gate_id,
                gate_type=GateType.SCHEMA_VALID,
                success=False,
                message="Missing artifact or schema path"
            )

        # Check artifact exists
        if not Path(artifact_path).exists():
            return GateResult(
                gate_id=gate_id,
                gate_type=GateType.SCHEMA_VALID,
                success=False,
                message=f"Artifact not found: {artifact_path}"
            )

        # Check schema exists
        if not Path(schema_path).exists():
            return GateResult(
                gate_id=gate_id,
                gate_type=GateType.SCHEMA_VALID,
                success=False,
                message=f"Schema not found: {schema_path}"
            )

        # Use existing verifier logic (import and delegate)
        try:
            from ..verifier import Verifier

            verifier = Verifier(schema_dir=str(Path(schema_path).parent))
            result = verifier.verify_artifact(artifact_path, schema_path)

            return GateResult(
                gate_id=gate_id,
                gate_type=GateType.SCHEMA_VALID,
                success=result.get("valid", False),
                message=result.get("message", "Schema validation result"),
                details=result
            )
        except ImportError:
            # Fallback if verifier not available
            return GateResult(
                gate_id=gate_id,
                gate_type=GateType.SCHEMA_VALID,
                success=False,
                message="Verifier module not available"
            )
        except Exception as e:
            return GateResult(
                gate_id=gate_id,
                gate_type=GateType.SCHEMA_VALID,
                success=False,
                message=f"Schema validation failed: {str(e)}"
            )

    def register_custom_gate(
        self,
        gate_type: str,
        handler: Callable[[Dict[str, Any], List[str], Optional[Dict[str, Any]]], GateResult]
    ) -> None:
        """
        Register a custom gate handler.

        Args:
            gate_type: Custom gate type name
            handler: Function(gate, artifacts, context) -> GateResult
        """
        self._custom_handlers[gate_type] = handler

    def unregister_custom_gate(self, gate_type: str) -> bool:
        """
        Unregister a custom gate handler.

        Args:
            gate_type: Custom gate type name to remove

        Returns:
            True if handler was removed, False if not found
        """
        if gate_type in self._custom_handlers:
            del self._custom_handlers[gate_type]
            return True
        return False

    def get_registered_gates(self) -> List[str]:
        """
        Get list of all registered gate types.

        Returns:
            List of gate type names (built-in and custom)
        """
        builtin = [gt.value for gt in GateType if gt != GateType.CUSTOM]
        custom = list(self._custom_handlers.keys())
        return builtin + custom

    def aggregate_gate_results(self, results: List[GateResult]) -> Dict[str, Any]:
        """
        Aggregate multiple gate results into a summary.

        Args:
            results: List of GateResult objects

        Returns:
            Summary dictionary with overall status
        """
        total = len(results)
        passed = sum(1 for r in results if r.success)
        failed = total - passed

        return {
            "overall_success": failed == 0,
            "total_gates": total,
            "gates_passed": passed,
            "gates_failed": failed,
            "results": [
                {
                    "gate_id": r.gate_id,
                    "gate_type": r.gate_type.value,
                    "success": r.success,
                    "message": r.message,
                    "details": r.details
                }
                for r in results
            ]
        }
